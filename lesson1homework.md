# ДЗ к уроку 1

### 1. Прочитать в книге "Грокаем алгоритмы" или в предложенных материалах про алгоритмы и О-большое

*готово*

### 2. Определить сложность следующих алгоритмов:

- Поиск элемента массива с известным индексом. **Решение:** Если индекс известен, то обращение к элементу массива происходит за фиксированное время. Следовательно, сложность данного алгоритма будет *O(1)*. **Ответ:** *O(1)*.
- Дублирование одномерного массива через foreach. **Решение:** Данный алгоритм совершает следующие операции: создание дублирующего массива - не зависит от объёма массива, выполняется за фиксированное время *O(1)*, обращение к элементу исходного массива и запись его значения в целевой массив. Каждая из этих операций имеет фиксированное время выполнения *O(1)*, но выполняются они для каждого элемента исходного массива. Следовательно, время выполнения данной части алгоритма будет *O(n)*, где *n* - количество элементов исходного массива. Согласно правилам анализа сложности алгоритмов, значение имеет только часть с наиболее быстро растущей сложностью от количества входных данных. Значит, итоговая сложность рассматриваемого алгоритма будет равна *O(n)*. **Ответ:** *O(n)*.
- Удаление элемента массива с известным индексом без сдвига. **Решение:** Слабо представляю, как можно удалить элемент массива без сдвига. Массив не может быть с дыркой. Предположим, что "удаляемый" элемент будет заменен неким значением, которое будет обозначать, что элемент "отсутствует". Например, ссылкой на *null*. Выполнение данной операции для элемента с заданным индексом будет иметь сложность *O(1)*. **Ответ:** *O(1)*.
- Удаление элемента массива с неизвестным индексом без сдвига. **Решение:** Для удаления элемента с неизвестным индексом сначала нужно его найти. Про структуру массива в задании ничего не сказано, поэтому предполагаем худший вариант: массив не имеет порядка. Поиск ведётся простым перебором элементов. Такой поиск имеет сложность *O(n)*. Если элемент найден, выполняется его "удаление" без сдвига. Как было рассмотрено в предыдущем примере, сложность этой операции составляет *O(1)*. Выбирая наиболее быстро растущую сложность, получаем итоговое значение для алгоритма в целом *O(n)*. **Ответ:** *O(n)*.
- Удаление элемента массива с неизвестным индексом со сдвигом. **Решение:** Данный алгорим будет состоять из следующих шагов:
        1. Поиск элемента по значению. Сложность *O(n)* (см. предыдущий пример)
        2. Если элемент найден, создаём новый массив размером *n-1*, т.к. в Java нельзя менять размер массива. Сложность *O(1)*
        3. В новый массив поочерёдно копируем все элементы исходного массива, пропуская тот, который был найден на шаге *1*. Сложность *O(n)*.
        4. Запись в переменную, указывающую на исходный массив, ссылки, указывающей на новый массив. Сложность *O(1)*.
        5. Складывая сложности всех шагов и сокращая лишнее, получим итоговую сложность алгоритма *O(n)*. **Ответ:** *O(n)*.
### 3. Определить сложность следующих алгоритмов. Сколько произойдет итераций?

#### a)

```
1: int n = 10000;
2: List<Integer> arrayList = new ArrayList<>();
3:     for (int i = 0; i < n; i++) {
4:         for (int j = 1; j < n; j *= 2) {
5:             arrayList.add(i * j);
6:         }
7:     }
```

**Решение:** Цикл, объявленный в строке *3*, отработает *n* раз - линейное приращение переменной цикла на единицу на каждом шаге. Цикл, объявленный в строке *4*, отработает *log(n)* раз (основание логарифма в данном случае равно *2*) - степенное приращение переменной цикла. Так как циклы вложены, количество итераций перемножается. Получим *n * log(n)* итераций. Это и будет итоговая сложность данного алгоритма. Все остальные его шаги имеют сложность *O(1)*. Количество итераций при *n = 10000*: *10000 х log(10000) = 1.4 x 10^5*

**Ответ:** *O(n * log(n))*; *1.4 x 10^5* итераций.

#### b)

```
1: int n = 10000;
2: List<Integer> arrayList = new ArrayList<>();
3: for (int i = 0; i < n; i += 2) {
4:     for (int j = i; j < n; j++) {
5:         arrayList.add(i * j);
6:     }
7: }
```

**Решение:** Цикл, объявленный в строке *3*, отработает *n/2* раз. Цикл, объявленный в строке 4, будет отрабатывать *(n-i)* раз на каждом шаге внешнего цикла. При этом *i = n/2*. Значит, внутренний цикл будет отрабатывать *(n-n/2) = (n/2)* раз. Перемножая эти значения, получим *(n/2)(n/2) = (n^2)/4* итераций. Сокращая коэффициенты, получим сложность алгоритма *O(n^2)*. Остальные шаги имеют фиксированное время выполнения. Количество итераций при *n = 10000*: *10000^2/4 = 2.5 x 10^7*.

**Ответ:** *O(n^2)*; *2.5 x 10^7* итераций.

#### c)

```
1: int n = 10000;
2: List<Integer> arrayList = new ArrayList<>();
3: for (int i = 0; i < n; i ++) {
4:     for (int j = 0; j < n; j++) {
5:         arrayList.add(i * j);
6:         n--;
7:     }
8: }
```

**Решение: ** Обозначим отдельно константой *N* исходное значение переменной *n*, чтобы не путать между собой объём исходных данных и значение *n*, меняющееся по мере выполнения кода. Далее:

- *N* - исходный объём входных данных
- *n* - значение переменной *n* в ходе выполнения алгоритма

Внутренний цикл первый раз отработает *N/2* раз: если бы не было строки *6*, то он бы отработал *N* раз (простой инкремент счётчика цикла), но на каждом его шаге происходит декремент конечного значения счётчика *n*, и к моменту, когда счётчик достигнет значения *N/2*, конечное значение счётчика цикла так же достигнет значения *N/2*, и цикл будет завершён.

Далее начнётся следующий шаг внешнего цикла, но значение переменной *n* уже будет равно *N/2* после первого выполнения внутреннего цикла. Внутренний цикл на второй итерации внешнего цикла отработает *n/2 = N/2/2 = N/4* раз. По завершению внутреннего цикла *n* снова уменьшится вдвое. Получим, что на каждом шаге внешнего цикла внутренний цикл будет отрабатывать *(N/2)^i = N x (1/2)^i*, где *i* - счётчик внешнего цикла. Общее же количество итераций будет равно сумме *N x (1/2)^i* при *i* от нуля до *log(N)* (логарифм здесь по основанию 2). *log(N)* в этой формуле есть ни что иное, как количество итераций внешнего цикла: т.к. на каждой его итерации предельное значение счётчика уменьшается вдвое, а счётчик приращается простым инкрементом, то общее число шагов будет равно двоичному логарифму от объёма исходных данных. Вернёмся к формуле общего количества итераций в двух циклах (обозначим данную величину буквой *X*):

```
    log(N)          log(N)
    ____            ____
    \               \
X =   N*(1/2)^i = N*     (1/2)^i        (C.1)
    /___            /___
    i = 0           i = 0
```

При *N = 10000* получим по данной формуле количество шагов *X = 9999*. Здесь возможна некоторая погрешность. Сложность же данного алгоритма будет следующей. Если взглянуть на формулу (C.1) при *N*, стремящемся к бесконечности, увидим известный математический ряд, который сходится к единице. В нашем случае важно, что к константе. Соответственно, количество шагов алгоритма не будет зависеть от части формулы под суммой, и целиком будет определяться только множителем перед знаком суммы, т.е. *N*. Итого сложность данного алгоритма будет *O(n)*.

**Ответ:** *O(n)*; *9999 приблизительно.*

#### d)

```
factorial(BigInteger.valueOf(10000))

public static BigInteger factorial(BigInteger n) {
    if (n.equals(BigInteger.ONE)) {
        return n;
    }
    return n.multiply(factorial(n.subtract(BigInteger.valueOf(1))));
}
```

**Решение:** Алгоритм представляет из себя рекурсию. Внутри функции происходят операции, занимающие фиксированное время. Значение имеет только количество вызовов функции. Оно будет равно *n*. Таким образом, для *n = 10000* функция будет вызвана 10000 раз, а общая сложность алгоритма составит *O(n)*.

**Ответ:** *O(n)*; *10000*.

#### e)

```
fib(BigInteger.valueOf(50));

public static BigInteger fib(BigInteger n) {
    if (n.equals(BigInteger.ONE)) {
        return BigInteger.ZERO;
    }
    if (n.equals(BigInteger.TWO)) {
        return BigInteger.ONE;
    }
    return fib(n.subtract(BigInteger.ONE)).add(fib(n.subtract(BigInteger.TWO)));
}
```

**Решение:** Алгоритм представляет из себя рекурсию, каждый вызов функции в которой порождает два вызова функции. Соответственно, на каждом шаге в глубину количество вызовов функции удваивается. Складывая все вызовы функции от самого первого, получим:

```
    N
    ____
    \
X =   2^n        (E.1)
    /___
    n = 0
```

Точное значение данной суммы рассчитывается по формуле *X = 2^(N+1) - 2*. Для значения *N = 50* получим: X = 2^(50+1) - 2 = *2.251799814 x 10^15* приблизительно. Сложность же алгоритма составит *O(a^n)*.

**Ответ: ** *O(a^n)*; *2.251799814 x 10^15*.

### Факультативные задания к уроку 1
#### 1

Простые делители числа 13195 - это 5, 7, 13 и 29. Каков самый большой делитель числа 600851475143, являющийся простым числом? Проверить ответ можно здесь(нужна регистрация)

**Решение** представлено в классе *SimpleDivisor.java*

#### 2

Требуется написать метод, принимающий на вход размеры двумерного массива и выводящий массив в виде инкременированной цепочки чисел, идущих по спирали.

Примеры:

```
2х3
1 2
6 3
5 4

3х1
1 2 3

4х4
01 02 03 04
12 13 14 05
11 16 15 06
10 09 08 07

0х7
Ошибка!
```

**Решение** представлено в классе *Spiral.java*

#### 3

Реализовать функцию a+b, где каждое из чисел а и b имеет не менее 1000 разрядов. Числа хранятся в файле chisla.txt на двух строчках. Ответ вписать на третью строчку. Использовать BigInteger не допускается

**Решение** представлено в классе *BigSumm.java*